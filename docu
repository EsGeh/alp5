Aufgabe (1)

a)Die Datei GenericProcess.Java implementiert die Aufgabenstellung.

b)Mit Send werden Messages an die Peers verschickt. Mit Recv wird eine an den Prozess verschickte Nachricht ausgegeben.
Das Problem mit der Go-Implementierung ist as Fehlen von Generic Types in Go. Daher ist man gezwungen mit  Any jeden Datentyp
zuzulassen und später passend zu casten. Dies ist umständlicher als in Java und birgt zudem Sicherheitsrisiken, falls man
nicht alle Prozesse selbst kontrolliert und "falsche" Datentypen verschickt werden, die beim Casten dann für Probleme sorgen, die
gegebenenfalls nicht bemerkt werden oder - besser - Laufzeitfehler verursachen.
Siehe auch: die für d) implementierten Tests!

c)Die in Node.Java implementierten Nodes haben über UDPInImpl.java und UDPOutImpl.java wie in b) Zugriff auf send- und recv-Funktionen,
die für den nicht an der Implementierung interessierten Nutzer wie erwartet funktionieren. Das Aufsetzen eines Systems mehrerer Nodes
kann aus dem Test (siehe Aufgabenteil d!) abgelesen werden.

d)Wir haben alle drei Tests implementiert! Im Go-Ordner befindet sich im Test-Ordner eine Test-Datei. Im UDP-Ordner findet sich
eine TestUDP.Java. Die Lösung aus a) wird in TestProcess.Java im Process-Ordner getestet.

--

Aufgabe (2)

a) Die Tabelle hat 4 Spalten. In der ersten Spalte werden die Namen der anderen Prozesse eingetragen. In der zweiten Spalte steht die
Adresse des jeweiligen anderen Prozesses, an den eine Nachricht geschickt werden muss, um den gewünschten Prozess dieser Zeile zu
erreichen. In der dritten Spalte stehen die entsprechenden Ports. In der vierten Spalte steht der Abstand
des aktuell genutzen Übertragungsweges des Prozesses zu dem Prozess in der Tabelle.
Um zu unterscheiden, ob eine Nachricht eine "Message" ist, die einen Inhalt übermitteln soll, oder ob eine Nachricht die Gestalt des
Systems der Prozesse betrifft, unterscheiden wir zwischen gewöhnlichen und Meta-Nachrichten anhand eines Headers. Erstere Nachrichten
sind die forwards, letztere die updates.
Bei einem forward wird die Nachricht an die IP-Adresse weitergegeben, die hinter dem Namen, an den die Nachricht
adressiert ist, aufgeführt ist. Der Prozess mit der entsprechenden IP-Adresse kann dann entweder gleich dem adressierten Prozess sein
oder aber ein Prozess zwischen Absender und Empfänger. In diesem Fall muss die Nachricht mit Hilfe der Tabelle des Übermittlers weiter
in Richtung Empfänger übertragen werden. Beim nächsten durch die IP-Adresse bestimmten Prozess findet wieder das gleiche statt, bis die
Nachricht letztendlich den Empfänger erreicht.
Kommt ein neuer Prozess in das System, ist es notwendig die Routing-Tabellen zu verändern. Einerseits muss der neue Prozess adressiert
werden können von allen Prozessen, andererseits könnten neue kürzeste Distanzen auftreten und das Routing verändern. Ein neuer Prozess
schickt an alle per IP bekannten Nachbarn eine Initialnachricht. Diese enthält den Namen des neuen Prozesses und fordert die anderen
Prozesse auf, den neuen Prozess zu registrieren. Die benachbarten Prozesse aktualisieren ihre Routingtabellen naheliegend mit Adresse,
Distanz und Namen des neuen Prozesses(die Distanz ist selbstverständlich 1). Diese benachbarten Prozesse können also den neuen Prozess
direkt nun erreichen. Nun werden von allen Prozessen, also auch dem neuen, solange update-Nachrichten verschickt, solange die
Routing-Tabellen durch die Nachrichten anderer Prozesse verändert werden. Eine Veränderung findet immer dann statt, wenn ein neuer
Prozess in eine Routing-Tabelle eingetragen wird oder aber eine der IP-Adressen(wegen eines neuen kürzesten Wegen) sich ändert und
mittelbar auch bei anderen Prozessen Änderungen des kürzesten Weges auftreten könnten. Finden irgendwann keine Änderungen der Tabellen
mehr statt, weil alle neuen Informationen einmal durch das System übertragen wurden, hören die update-Messages auf und es tritt keine
"Dauerschleife" von update-Nachrichten auf.

b+c)Die geforderten Dateien sind vorhanden und benutzbar.

