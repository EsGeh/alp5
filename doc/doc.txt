Alp5 - Übung 7 


Bearbeitung:
	André Röhrig
	Samuel Gfrörer
Tutor:
	Marco Träger
Tutorium:
	Mittwochs um 14 Uhr


1. Verteiltes Wörterbuch.
	Gemeinsamer Code für Server und Client: 
		Quellcode: ./interfaces/
	Server:
		Quellcode: ./server/src/
		Binärcode: ./server/bin/
	Client:
		Quellcode: ./client/src/
		Binärcode: ./client/bin/

Dokumentation des Programmdesigns (-> 1. d) )
	./doc/uml.*
	Kommentar zum UML-Diagramm und zum Kompilieren:
		Die Pakete symbolisieren eine Einteilung des Quellcodes:
		* Quellcode für die Klassen im Paket "server" wird ausschließlich zum Kompilieren des Servers benötigt.
		* Quellcode für die Klassen im Paket "client" wird ausschließlich zum Kompilieren des Clients benötigt.
		* Quellcode in "interfaces" wird zum Kompilieren von Server UND Client benötigt

Einfach Möglichkeit zum Kompilieren mittels Eclipse:
	* 2 Projekte anlegen - eines für Server (auf ./server), eines für den Client (auf ./client)
	* füge ./interfaces als zusätzliches Quellcode-Verzeichnis zu beiden Projekten hinzu
	* jetzt sollten die Binärdateien an den richtigen Stellen sein.


1.a) Implementierung mittels RMI:
	Hilfsskripte:
		./startJavaRMI.sh	startet den java rmi server
		./startRMIServer.sh	startet den Serverprozess
		./startRMIClient.sh	startet den Clientprozess
	Testlauf zur Zeitmessung:
		(Auf dem Server-Rechner:)
		$ ./startJavaRMI &
		$ ./startRMIServer
			server has been started successfully
		(Auf dem Client-Rechner:)
		$ ./startRMIClient.sh 
			Hello to the distributed dictionary!
			type an english word to find a german translation. ^D to exit
		> bla
			entry not found!
		> hurz
			entry not found!
		> tree
			result: [Baum] (answer time: 5384.528us)
		> failure
			result: [Fehlschlag, Misserfolg, Versager] (answer time: 1557.278us)
		> message
			result: [Botschaft, Nachricht] (answer time: 3238.631us)

1.b) Implementierung mittels TCP:
	Testlauf zur Zeitmessung:
		(Auf dem Server-Rechner:)
		$ java -cp server/bin TCPServer dictionary 8000
			server started
		(Auf dem Client-Rechner:)
		$ java -cp client/bin TCPClient localhost 8000
			Hello to the distributed dictionary!
			type an english word to find a german translation. ^D to exit
		> bla
			result: [] (answer time: 1149.876us)
		> hurz
			result: [] (answer time: 39093.234us)
		> tree
			result: [Baum] (answer time: 40313.047us)
		> failure
			result: [Fehlschlag, Misserfolg, Versager] (answer time: 39093.777us)
		> message
			result: [Botschaft, Nachricht] (answer time: 37068.336us)

1.d) ja, siehe "Dokumentation des Programmdesigns (-> 1. d) )" weiter oben

1.e) die RMI-Variante ist deutlich schneller als die TCP-Variante. Dies könnte daran liegen, da in unserem Test-Szenario Server und Client auf dem gleichen Rechner gestartet werden. Vermutlich wird dies von der JVM erkannt, und der Umweg über das IP-Protokoll vermieden. In der TCP-Variante hingegen müssen erzwungenermaßen TCP- und IP-Pakete gepackt und (wenn auch lokal) verschickt werden.



Aufgabe (2)
Es wird ausgegeben: there :mumps
                    here : xxx

Wenn "Map<String, String> there = m1.dump();" ausgeführt wird, kann nicht wie bei here nur ein Zeiger kopiert werden, denn da
angenommen werden muss, dass auf there remote zugegriffen wird, wäre es nicht sinnvoll die Stelle im Speicher des anderen
Computer zu kennen, an der die Map liegt. Es muss also serialisiert werden. Wenn dann "xxx" an dem key "disease" bei there
geschrieben wird, wird diese Kopie verändert. Bei Aufruf von m1.lookup wird dann aber wieder die "ursprüngliche" Map benutzt, die
seit dem dump() gar nicht mehr verändert wurde. Daher wird dann auch "mumps" ausgegeben.

Anders bei m2: Bei allen analogen Operationen zu der zuvor erwähnten map("there","m1",...) wird bei (m2,here) immer nur der Zeiger
weitergegeben, auch bei "Map<String, String> here  = m2.dump();"; denn es ist hier kein remote Zugriff möglich durch die Konstitution
von "this" bzw. "m2". Daher wird ganz gewöhnlich immer der Zeiger weitergegeben und auch bei here.put() wird auf die Map von m2 zuge-
griffen und nicht auf eine neu angelegte Kopie. Daher wird "m2.lookup("disease")" dann "xxx" zurückgeben, schließlich wurde zuvor
mit "here.put("disease", "xxx");" die gleiche Map verändert, die nun partiell ausgegeben werden soll.

Aufgabe (3)
Entscheidend ist, ob das Interface Ring Serializable oder Remote erweitert. So wie der Code aussieht, würde man nur eine Exception
erhalten.
Fall 1(Serializable): In diesem Fall würde in der Klasse RMI bei ring.create und ring.get jeweils eine neue lokale Kopie angelegt
werden. Das Resultat wäre, dass "0" ausgegeben werden würde, da ring.get auf einen "anderen" Ring zugriffe als ring.create.

Fall 2(Remote): In diesem Fall würde in der Klasse RMI bei ring.create und ring.get auf den selben Ring zugegriffen. Anders gesagt:
"rings.create("first", 7)" gibt einen Fernverweis zurück, so wie auch "rings.get()", und zwar auf das selbe Objekt. Flood und das
andere get(des Rings-Interface) greifen demnach auf das selbe Objekt zu.
Das Resultat wäre, dass "4711" ausgegeben werden würde, da ring.get auf den gleichen Ring zugriffe wie ring.create.
