1. c) Testen zeigt, dass die verteilte Lösung deutlich schneller ist, bei großen Eingaben wird nur etwa halb so viel Zeit verbraucht auf einem Multicore-System,
aber auch auf 32-Bit-Einkernprozessoren ist die verteilte (mit n=2) Lösung schneller, weil der Text und das Wörterbuch vervielfältigt werden und der Zugriff
auf die Daten der Flaschenhals des Problems ist. Verglichen haben wir, indem wir die Linux-Standardfunktion "time" vor die Ausführung des Shellscripts bzw. den 
nicht verteilten Aufruf des check-Funktion, die wir an das Histogramm-Skript gepipet haben, gesetzt haben.

2. a) siehe ./2a.png

b) Verteiltes System in Haskell:
	Ordner: ./aufgabe2/haskell/
	Quellcode: sort.hs
	Compilieren:
		cabal configure
		cabal build
	Ausführen:
		./dist/build/sort/sort OPTIONS
	OPTIONS:
		-lsd: sortiert die Folge vom kleinsten bis zum größten bit
		-msd: sortiert die Folge vom größten bis zum kleinsten bit
	Spezifikation:
		erwartet eine liste von zahlen, durch newline getrennt. gibt die sortierte Liste aus
	Bemerkung:
		es gibt 2 Varianten, um Zahlen mittels Radix-Sort zu sortieren - vom kleinsten bis zum höchsten, oder vom höchsten bis zum kleinsten Bit. Das Haskell-Programm ermöglicht beide Varianten. Die Variante die dem Flussgraphen aus 2a) entspricht, ist heißt im Quellcode "sortLSD".

c) Das Programm verwendet die Implementierung von "f" in Go:
	Ordner: ./aufgabe2/go/
	Quellcode: src/fProg/fProg.go, src/f/f.go
	Compilieren:
		./build.sh
	Ausführen:
		./bin/fProg DIGIT
	DIGIT: die Binärstelle, nach der sortiert werden soll
	Spezifikation:
		erwartet 2 Listen von der Standardeingabe, und gibt 2 sortierte Listen aus. Ein- und Ausgabe haben folgende Syntax:
		"i1 i2 i3 ... | i4 i5 i6 ..." steht für 2 Listen ([i1, i2, i3, ... ], [i4, i5, i6, ...]

Außerdem gibt es das Bash-Skript "shellSort.sh":
	./aufgabe2/
	quellcode: ./shellSort.sh
	ausführen:
		./shellSort.sh
	Spezifikation:
		Eingabe: eine Liste von Zahlen, wahlweise durch Leerzeichen oder Newline getrennt
		Ausgabe: eine geordnete Liste von Zahlen, getrennt durch Newline

d) Bei der Verkettung von f's als Filter ist entscheidend, dass diese im richtigen Moment blockieren, bevor sie die Ausgabe machen. Die Funktion besteht aus 2 Schritten:
	1. sortieren der beiden Eingabelisten
	2. Konkatenieren der Ergebnisse (im Code: (a++c, b++d) )
Schritt 1. kann nebenläufig stattfinden. Bevor Schritt 2. passiert, müssen die insgesamt 4 Ergebnis-Listen aus Schritt 1. vollständig berechnet worden sein.
Im Falle einer Parallelisierung von Schritt 1. ergibt sich eine Verbesserung der Laufzeit. Genauer:
	Sei maxCountDigit die maximale Anzahl der Stellen, nach denen sortiert wird, n die Anzahl der Zahlen. Dann dauert
		1. im Erwartungsfall n/2 T
		2. konstante Zeit
	Da zum Vollständigen Sortieren aller Zahlen maxCountDigit Filter verkettet arbeiten müssen, ergibt sich die Gesamtlaufzeit
		maxCountDigit * (n/2 + const)
			(Dabei ist "const" die Zeit, die für Schritt 2. benötigt wird)

e) -- aus Zeitmangel ausgelassen --

f) Testen der Laufzeiten der verschiedenen Implementierungen:

f1): das Shellscript, f in Go implementiert (2c)):
$ time cat testData/numbers | ./shellSort.sh > /dev/null 

	real	0m17.339s
	user	0m13.837s
	sys	0m6.832s

f2): das HaskellProgramm:
$ time cat ../testData/numbers | ./dist/build/sort/sort -lsd > /dev/null 

real	0m0.956s
user	0m0.940s
sys	0m0.012s

f3): das Dienstprogramm "sort"
time cat ../testData/numbers | sort > /dev/null 

real	0m0.206s
user	0m0.192s
sys	0m0.008s


Ergebnis: 
Am besten schneidet das Dienstprogramm "sort" ab. Es nutzt vermutlich keinen Radix-Sort, der für einen so großen Wertebereich sehr ineffizient ist.
Das HaskellProgramm ist mit ca. 1 sec am zweitschnellsten. Es nutzt zwar Radix-Sort, kann aber in ein sehr effizientes Programm übersetzt werden.
Das Shellskript als Frontend für ein Go Programm, ist am langsamsten, es benötigt über 15 sec, um die Testdaten zu sortieren. Hier wirken sich die Eigenschaften von Bash als interpretierte Skriptsprache negativ aus.


